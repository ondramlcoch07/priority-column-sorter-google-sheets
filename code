function onEdit(e) {
  if (!e) return;

  const sheet = e.source.getActiveSheet();
  const editedRow = e.range.getRow();
  const editedCol = e.range.getColumn();

  const idCol = 1; // Hidden ID column in column A
  const instructionRow = 2; // Row with sorting instructions

  // Automatically hide the ID column if itâ€™s not hidden
  if (!sheet.isColumnHiddenByUser(idCol)) {
    sheet.hideColumn(sheet.getRange(1, idCol));
  }

  // Don't trigger if editing ID column
  if (editedCol === idCol) return;

  // --- Check if the edited column has a sorting instruction ---
  const instructions = sheet.getRange(instructionRow, 1, 1, sheet.getLastColumn()).getValues()[0];
  const hasSortInstruction = instructions[editedCol - 1] && instructions[editedCol - 1].toString().match(/\d+\.\s*(A-Z|Z-A)/i);

  if (!hasSortInstruction) return; // Do nothing if the column is not sorted

  // --- Hide row 2 only if the edit was not in row 2 ---
  if (editedRow !== instructionRow && !sheet.isRowHiddenByUser(instructionRow)) {
    sheet.hideRows(instructionRow);
  }

  // --- Only run sorting if edit is not in row 2 ---
  if (editedRow !== instructionRow) {
    autoSortColumns(sheet, editedRow, editedCol, idCol, instructionRow);
  }
}

function autoSortColumns(sheet, activeRow, activeCol, idCol, instructionRow) {
  const lastRow = sheet.getLastRow();
  const lastCol = sheet.getLastColumn();
  if (lastRow <= instructionRow) return; // nothing to sort

  // --- Ensure hidden ID column exists ---
  const idRange = sheet.getRange(instructionRow + 1, idCol, lastRow - instructionRow, 1);
  const ids = idRange.getValues();
  let changed = false;
  for (let i = 0; i < ids.length; i++) {
    if (!ids[i][0]) {
      ids[i][0] = Utilities.getUuid();
      changed = true;
    }
  }
  if (changed) idRange.setValues(ids);

  const activeId = sheet.getRange(activeRow, idCol).getValue();

  // --- Save original row positions ---
  const originalIds = sheet.getRange(instructionRow + 1, idCol, lastRow - instructionRow, 1).getValues().map(r => r[0]);

  // --- Build sorting instructions ---
  const instructions = sheet.getRange(instructionRow, 1, 1, lastCol).getValues()[0];
  const sortInstructions = [];
  instructions.forEach((instr, i) => {
    if (instr && i + 1 !== idCol) {
      const match = instr.toString().match(/(\d+)\.\s*(A-Z|Z-A)/i);
      if (match) {
        sortInstructions.push({
          column: i + 1,
          priority: parseInt(match[1]),
          ascending: match[2].toUpperCase() === "A-Z"
        });
      }
    }
  });
  if (sortInstructions.length === 0) return;

  // Sort by priority ascending
  sortInstructions.sort((a, b) => a.priority - b.priority);

  const sortSpecs = sortInstructions.map(instr => ({
    column: instr.column,
    ascending: instr.ascending
  }));

  // --- Sort data (row 3 down, all columns) ---
  const range = sheet.getRange(instructionRow + 1, 1, lastRow - instructionRow, lastCol);
  range.sort(sortSpecs);

  // --- Only move active cell if row actually changed ---
  const allIds = sheet.getRange(instructionRow + 1, idCol, lastRow - instructionRow, 1).getValues().map(r => r[0]);
  const oldIndex = originalIds.indexOf(activeId);
  const newIndex = allIds.indexOf(activeId);

  if (oldIndex !== newIndex && newIndex >= 0) {
    const newRowIndex = instructionRow + 1 + newIndex;
    sheet.setActiveSelection(sheet.getRange(newRowIndex, activeCol));
  }
}
